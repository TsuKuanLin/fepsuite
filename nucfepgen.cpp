#include "cmdline.h"
#include "bestfit.hpp"
#include "pdb.hpp"
#include "topology.hpp"
#include "assign.hpp"
#include "select.hpp"

#include <iostream>
#include <iomanip>
#include <fstream>
#include <limits>

using namespace std;
using namespace Eigen;

bool verbose = false;
bool quiet = false;

 
int main(int argc, char* argv[])
{
  cmdline::parser p;
  
  p.add("help", 0, "Print this message");
  p.add("verbose", 'v', "Be more verbose");
  p.add("quiet", 'q', "Suppress unnecessary information");
  p.add<double>("maxdist", 0, "Maximum distances to fit", false, 1.5);
  p.add("debug", 0, "Debug");

  p.add<string>("structureA", 'A', "PDB structure A", true);
  p.add<string>("structureB", 'B', "PDB structure B", true);
  p.add<string>("topologyA", 'a', ".top A", true);
  p.add<string>("topologyB", 'b', ".top B", true);
  p.add<string>("structureO", 'O', "PDB structure to output", true);
  p.add<string>("topologyO", 'o', ".top output", true);

  bool ok = p.parse(argc, argv);

  if (!ok || p.exist("help")) {
    cerr << p.usage();
    return ((ok && p.exist("help")) ? 0 : 1);
  }
  verbose = p.exist("verbose");
  quiet = p.exist("quiet");

  pdb Apdb(p.get<string>("structureA"));
  pdb Bpdb(p.get<string>("structureB"));
  topology Atop(p.get<string>("topologyA"));
  topology Btop(p.get<string>("topologyB"));

  Matrix3Xd Acoords, Bcoords;
  Acoords = Apdb.get_coords();
  Bcoords = Bpdb.get_coords();

  const vector<string>& Anames = Apdb.get_atomnames();
  const vector<string>& Bnames = Bpdb.get_atomnames();

  // fit Bpdb structure into Apdb by comparing P-coordinates
  {
    
    VectorXd Amass = set_selected_mass(Anames, "P");
    VectorXd Bmass = set_selected_mass(Bnames, "P");

    fit_selected(Amass, Bmass, Acoords, Bcoords);
  }

  // make a distance matrix
  MatrixXd distmat(Acoords.cols(), Bcoords.cols());

  for(int ia = 0; ia < Acoords.cols(); ++ia) {
    char chainA = Apdb.get_chains()[ia];
    for(int jb = 0; jb < Bcoords.cols(); ++jb) {
      char chainB = Bpdb.get_chains()[jb];
      // Quick hack: prevent different chain atoms to be assigned the same atom
      distmat(ia, jb) = 
        (chainA == chainB ? 
         (Acoords.col(ia) - Bcoords.col(jb)).norm()
         : numeric_limits<double>::max());
    }
  }

  // assign atoms by distance
  vector<int> assignBofA(Acoords.cols(), -1);
  vector<int> assignAofB(Bcoords.cols(), -1);

  double pdist = p.get<double>("maxdist");
  assign_atoms("P",   Anames, Bnames, distmat, assignBofA, assignAofB, pdist);
  assign_atoms("NCO", Anames, Bnames, distmat, assignBofA, assignAofB, pdist);
  assign_atoms("H",   Anames, Bnames, distmat, assignBofA, assignAofB, pdist);

  if(!quiet){
    cout << "Atoms assigned:" << endl;
    cout << "Assigned:" << endl;
    for(int i = 0; i < (int)Anames.size(); ++i) {
      if(assignBofA[i] != -1) {
        int j = assignBofA[i];
        cout << " " 
             << Apdb.get_chains()[i] << ":"
             << Apdb.get_residuenames()[i] << ":"
             << Apdb.get_resids()[i] << ":" << Anames[i] 
             << " -> " 
             << Bpdb.get_chains()[j] << ":"
             << Bpdb.get_residuenames()[j] << ":"
             << Bpdb.get_resids()[j] << ":" << Bnames[j]
             << endl;
      }
    }
    cout << "Unssigned in A:" << endl;
    for(int i = 0; i < (int)Anames.size(); ++i) {
      if(assignBofA[i] == -1) {
        cout << " "
             << Apdb.get_chains()[i] << ":"
             << Apdb.get_residuenames()[i] << ":"
             << Apdb.get_resids()[i] << ":" << Anames[i] 
             << endl;
      }
    }
    cout << "Unassigned in B:" << endl;
    for(int i = 0; i < (int)Bnames.size(); ++i) {
      if(assignAofB[i] == -1) {
        cout << " " 
             << Bpdb.get_chains()[i] << ":"
             << Bpdb.get_residuenames()[i] << ":"
             << Bpdb.get_resids()[i] << ":" << Bnames[i] 
             << endl;
      }
    }
  }

  int Bunassigned = 0;
  for(int i = 0; i < (int)Bnames.size(); ++i) {
    if(assignAofB[i] == -1) Bunassigned++;
  }
  int N = Acoords.cols() + Bunassigned;
  
  // Make map from A/B, to/from output
  vector<int> assignOofA(Acoords.cols(), -1);
  vector<int> assignOofB(Bcoords.cols(), -1);
  vector<int> assignAofO(N, -1);
  vector<int> assignBofO(N, -1);

  for(int i = 0; i < (int)assignOofA.size(); ++i) {
    assignOofA[i] = i;
    assignAofO[i] = i;
  }
  for(int j = 0, ptr = Acoords.cols();
      j < (int)assignOofB.size(); ++j) {
    if(assignAofB[j] == -1) {
      assignOofB[j] = ptr;
      ptr++;
    }else{
      assignOofB[j] = assignOofA[assignAofB[j]];
    }
    assignBofO[assignOofB[j]] = j;
  }

  // output 
  ofstream Ofs(p.get<string>("topologyO"));
  Ofs.setf(ios::scientific);
  Ofs.setf(ios::right);
  Ofs << setprecision(5);

  Ofs << "; generated by:" << endl;
  Ofs << ";  " << argv[0];
  for(int i = 1; i < argc; ++i) {
    Ofs << " " << argv[i];
  }
  Ofs << endl;
  
  // Defaults section
  if(Atop.defaults != topology::topotype::AMBER ||
     Btop.defaults != topology::topotype::AMBER) {
    cerr << "Unsupported defaults type" << endl;
    exit(1);
  }
  Ofs << "[ defaults ]" << endl;
  Ofs << "; nbfunc        comb-rule       gen-pairs       fudgeLJ fudgeQQ" << endl;
  Ofs << "1               2               yes             0.5     0.8333" << endl;
  Ofs << endl;

  // atomtypes section
  Ofs << "[ atomtypes ]" << endl;
  for(const auto& v: Atop.atomtypes) {
    Ofs << v.second << endl;
  }
  for(const auto& v: Btop.atomtypes) {
    if(Atop.atomtypes.count(v.first) == 0) {
      Ofs << v.second << endl;
    }
  }
  // phantom type
  Ofs << "PHA PHA 0.0000 0.0000 A 0.0000 0.0000" << endl;
  Ofs << endl;

  // moleculetype section
  Ofs << "[ moleculetype ]" << endl;
  Ofs << ";name  nrexcl" << endl;
  Ofs << "merged " << Atop.nexcl << endl;
  Ofs << endl;

  // atoms section
  Ofs << "[ atoms ]" << endl;
  Ofs << ";   nr  type  resi  res  atom  cgnr     charge      mass       typeB chargeB massB" << endl;

  for(int i = 0; i < N; ++i) {
    // Fill in A-state
    if(assignAofO[i] != -1) {
      int aptr = assignAofO[i];
      Ofs << setw(4) << (i + 1)
          << " " << setw(3) << Atop.types[aptr]
          << " " << setw(4) << Atop.resids[aptr]
          << " " << setw(5) << Atop.resnames[aptr]
          << " " << setw(6) << Atop.names[aptr]
          << " " << setw(4) << (i + 1) // cgnr
          << " " << setw(12) << Atop.charges[aptr]
          << " " << setw(12) << Atop.masses[aptr];
    }else{
      int bptr = assignBofO[i];
      assert(bptr != -1);
      Ofs << setw(4) << (i + 1)
          << " " << setw(3) << "PHA"
          << " " << setw(4) << Btop.resids[bptr]
          << " " << setw(5) << Btop.resnames[bptr]
          << " " << setw(6) << Btop.names[bptr]
          << " " << setw(4) << (i + 1) // cgnr
          << " " << setw(12) << 0.000
          << " " << setw(12) << 12.000;
    }

    // Fill in B-state
    if(assignBofO[i] != -1) {
      int bptr = assignBofO[i];
      Ofs << " " << setw(3) << Btop.types[bptr]
          << " " << setw(12) << Btop.charges[bptr]
          << " " << setw(12) << Btop.masses[bptr];
    }else{
      Ofs << " " << "PHA"
          << " " << setw(12) << 0.000
          << " " << setw(12) << 12.000;
    }
    Ofs << endl;
  }
  Ofs << endl;

  // bonds section
  Ofs << "[ bonds ]" << endl;
  for(const auto& v: Atop.bonds) {
    topology::bondkeytype k = v.first;
    int x = std::get<0>(k);
    int y = std::get<1>(k);
    int func = std::get<2>(k);
    
    int x_in_O = assignOofA[x];
    int y_in_O = assignOofA[y];
    topology::bondkeytype keyB = 
      make_tuple(assignBofO[x_in_O],
                 assignBofO[y_in_O],
                 func);
    if(func != 1) {
      throw runtime_error("Bond func != 1 not supported");
    }
    const vector<double>& Afactors = v.second;
    vector<double> Bfactors(2, 0);
    if(Btop.bonds.count(keyB) > 0) {
      Bfactors = Btop.bonds[keyB];
    }else{
      Bfactors[0] = Afactors[0];
      Bfactors[1] = 0.0;
    }
    // output A-listed bonds first
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << func;
    for(auto v: Afactors) {
      Ofs << " " << v;
    }
    for(auto v: Bfactors) {
      Ofs << " " << v;
    }
    Ofs << endl;
  }
  // Remaining: not exists in A but exists in B
  for(const auto& v: Btop.bonds) {
    topology::bondkeytype k = v.first;
    int x = std::get<0>(k);
    int y = std::get<1>(k);
    int func = std::get<2>(k);
    
    int x_in_O = assignOofB[x];
    int y_in_O = assignOofB[y];
    topology::bondkeytype keyA = 
      make_tuple(assignAofO[x_in_O],
                 assignAofO[y_in_O],
                 func);
    if(Atop.bonds.count(keyA) > 0) {
      continue;
    }
    const vector<double>& Bfactors = v.second;
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << func
        << " " << Bfactors[0]
        << " " << 0.00;
    for(auto v: Bfactors) {
      Ofs << " " << v;
    }
    Ofs << endl;
  }
  Ofs << endl;

  // angles section (FIXME: kopipe)
  Ofs << "[ angles ]" << endl;
  for(const auto& v: Atop.angles) {
    topology::anglekeytype k = v.first;
    int x = std::get<0>(k);
    int y = std::get<1>(k);
    int z = std::get<2>(k);
    int func = std::get<3>(k);
    
    int x_in_O = assignOofA[x];
    int y_in_O = assignOofA[y];
    int z_in_O = assignOofA[z];
    topology::anglekeytype keyB = 
      make_tuple(assignBofO[x_in_O],
                 assignBofO[y_in_O],
                 assignBofO[z_in_O],
                 func);
    if(func != 1) {
      throw runtime_error("Angle func != 1 not supported");
    }
    const vector<double>& Afactors = v.second;
    vector<double> Bfactors(2, 0);
    if(Btop.angles.count(keyB) > 0) {
      Bfactors = Btop.angles[keyB];
    }else{
      Bfactors[0] = Afactors[0];
      Bfactors[1] = 0.0;
    }
    // output A-listed angles first
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << z_in_O + 1 << " "
        << func;
    for(auto v: Afactors) {
      Ofs << " " << setw(12) << v;
    }
    for(auto v: Bfactors) {
      Ofs << " " << setw(12) << v;
    }
    Ofs << endl;
  }
  // Remaining: not exists in A but exists in B
  for(const auto& v: Btop.angles) {
    topology::anglekeytype k = v.first;
    int x = std::get<0>(k);
    int y = std::get<1>(k);
    int z = std::get<2>(k);
    int func = std::get<3>(k);
    
    int x_in_O = assignOofB[x];
    int y_in_O = assignOofB[y];
    int z_in_O = assignOofB[z];
    topology::anglekeytype keyA = 
      make_tuple(assignAofO[x_in_O],
                 assignAofO[y_in_O],
                 assignAofO[z_in_O],
                 func);
    if(Atop.angles.count(keyA) > 0) {
      continue;
    }
    const vector<double>& Bfactors = v.second;
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << z_in_O + 1 << " " 
        << func
        << " " << setw(12) << Bfactors[0]
        << " " << setw(12) << 0.00;
    for(auto v: Bfactors) {
      Ofs << " " << setw(12) << v;
    }
    Ofs << endl;
  }
  Ofs << endl;

  // dihedrals (FIXME: kopipe again)
  Ofs << "[ dihedrals ]" << endl;
  for(const auto& v: Atop.diheds) {
    topology::dihedkeytype k = v.first;
    int x = std::get<0>(k);
    int y = std::get<1>(k);
    int z = std::get<2>(k);
    int w = std::get<3>(k);
    int func = std::get<4>(k);
    
    int x_in_O = assignOofA[x];
    int y_in_O = assignOofA[y];
    int z_in_O = assignOofA[z];
    int w_in_O = assignOofA[w];
    topology::dihedkeytype keyB = 
      make_tuple(assignBofO[x_in_O],
                 assignBofO[y_in_O],
                 assignBofO[z_in_O],
                 assignBofO[w_in_O],
                 func);
    if(func != 1 && func != 3) {
      throw runtime_error("dihed func not in {1, 3} not supported");
    }
    const vector<double>& Afactors = v.second;
    vector<double> Bfactors(Afactors);
    if(Btop.diheds.count(keyB) > 0) {
      Bfactors = Btop.diheds[keyB];
    }else{
      for(auto &&v: Bfactors) {
        v = 0.0;
      }
      if(func == 1) {
        Bfactors[0] = Afactors[0];
      }
    }
    // output A-listed angles first
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << z_in_O + 1 << " " << w_in_O + 1 << " "
        << func;
    for(auto v: Afactors) {
      Ofs << " " << setw(12) << v;
    }
    for(auto v: Bfactors) {
      Ofs << " " << setw(12) << v;
    }
    Ofs << endl;
  }
  // Remaining: not exists in A but exists in B
  for(const auto& v: Btop.diheds) {
    topology::dihedkeytype k = v.first;
    int x = std::get<0>(k);
    int y = std::get<1>(k);
    int z = std::get<2>(k);
    int w = std::get<3>(k);
    int func = std::get<4>(k);
    
    int x_in_O = assignOofB[x];
    int y_in_O = assignOofB[y];
    int z_in_O = assignOofB[z];
    int w_in_O = assignOofB[w];
    topology::dihedkeytype keyA = 
      make_tuple(assignAofO[x_in_O],
                 assignAofO[y_in_O],
                 assignAofO[z_in_O],
                 assignAofO[w_in_O],
                 func);
    if(Atop.diheds.count(keyA) > 0) {
      continue;
    }
    const vector<double>& Bfactors = v.second;
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << z_in_O + 1 << " " << w_in_O + 1 << " "
        << func
        << " " << setw(12) << (func == 1 ? Bfactors[0] : 0.00);
    for(size_t i = 1; i < Bfactors.size(); ++i) {
      Ofs << " " << setw(12) << 0.00;
    }
    for(auto v: Bfactors) {
      Ofs << " " << setw(12) << v;
    }
    Ofs << endl;
  }
  Ofs << endl;

  // pairs
  Ofs << "[ pairs ]" << endl;
  for(const auto& v: Atop.pairs) {
    auto k = v.first;
    int x = k.first;
    int y = k.second;
    int func = v.second;
    
    int x_in_O = assignOofA[x];
    int y_in_O = assignOofA[y];
    if(func != 1) {
      throw runtime_error("pairs func != 1 not supported");
    }
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << func << endl;
  }
  // Remaining: not exists in A but exists in B
  for(const auto& v: Btop.pairs) {
    auto k = v.first;
    int x = k.first;
    int y = k.second;
    int func = v.second;
    
    int x_in_O = assignOofB[x];
    int y_in_O = assignOofB[y];
    auto keyA = 
      make_pair(assignAofO[x_in_O],
                assignAofO[y_in_O]);
    if(Atop.pairs.count(keyA) > 0) {
      continue;
    }
    Ofs << x_in_O + 1 << " " << y_in_O + 1 << " " 
        << func << endl;
  }
  Ofs << endl;

  Ofs << "[ system ]" << endl;
  Ofs << "Merged structure from " 
      << p.get<string>("topologyA") 
      << " and " 
      << p.get<string>("topologyB")
      << endl;
  Ofs << endl;

  Ofs << "[ molecules ]" << endl;
  Ofs << "merged 1" << endl;
  Ofs << endl;

  return 0;
}

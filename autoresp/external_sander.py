#!/usr/bin/env python
import sys
import subprocess
import os
import os.path
import re

[ _exe,
  parameter, 
  _layer,
  inputfile,
  outputfile,
  msgfile,
  _fchkfile,
  _matelfile ] = sys.argv

sander = os.path.join(os.environ["AMBERHOME"], "bin/sander")
sanderin = "sander_pb.in"
sanderlog = "sander_pb.log"
ambtop = None
ambcrdfile = "coord.crd"
ambenefile = "energy.txt"
ambfrcfile = "force.txt"

# You have: kcal / mol / avogadro
# You want: hartree
# 	* 0.0015946679
kcal_to_hartree = 0.0015946679
#
aa_to_atomiclength = 1.8897261
atomiclength_to_aa = 1. / aa_to_atomiclength

with open(msgfile, "w") as msg:
    natom = None
    mm_of_gaussian = {}
    gaussian_of_mm = {}
    with open(parameter, "r") as fh:
        ambtop = fh.next().strip()
        natom = int(fh.next().strip())
        mmatoms = []
        gaussianatoms = []
        mm_ix = {}
        gaussian_ix = {}
        for _i in range(natom):
            l = fh.next()
            [mm] = l.split()
            mm_ix[mm] = len(mmatoms)
            mmatoms.append(mm)
        for _i in range(natom):
            l = fh.next()
            [gaussian] = l.split()
            gaussian_ix[gaussian] = len(gaussianatoms)
            gaussianatoms.append(gaussian)

        for i in range(natom):
            g = gaussian_ix[mmatoms[i]]
            mm_of_gaussian[g] = i
            gaussian_of_mm[i] = g

    gaussiancrd = [None for i in range(natom)]
    with open(inputfile, "r") as ifh:
        (natomsp, derivative, _charge, _spin) = ifh.next().split()
        natomsp = int(natomsp)
        assert natom == natomsp
        derivative = int(derivative)
        for i in range(natom):
            l = ifh.next()
            [_anum, x, y, z, _mmcrg] = l.split()[0:5]
            gaussiancrd[i] = [float(e) for e in [x, y, z]]

    mmcrd = [None for i in range(natom)]
    for i in range(natom):
        mmcrd[mm_of_gaussian[i]] = [x * atomiclength_to_aa for x in gaussiancrd[i]]
    
    # Amber and Gaussian shares same coordinate unit (angstrom)
    with open(ambcrdfile, "w") as crdfh:
        crdfh.write("Generated by external\n%6d\n" % natom)
        for i in range(0, natom, 2):
            e = min(i + 2, natom)
            vals = mmcrd[i:e]
            outbuf = ""
            for v in vals:
                for e in v:
                    outbuf += "%12.7f" % e
            crdfh.write(outbuf + "\n")

    # run
    args = [ sander, "-O",
             "-i", sanderin,
             "-o", sanderlog,
             "-p", ambtop,
             "-c", ambcrdfile,
             "-e", ambenefile,
             "-frc", ambfrcfile ]

    print >> msg, "Calling with", args
    proc = subprocess.Popen(args)

    (stdout, stderr) = proc.communicate()
    msg.write("Stdout:\n%s\nStderr:\n%s\n" % (stdout, stderr))

    # parse output - first, ene file
    with open(ambenefile, "r") as lfh:
        labels = []
        backindex = {}
        results = []
        for l in lfh:
            ls = l.split()
            li = int(ls[0][1:])
            if len(labels) <= li:
                labels.append(ls[1:])
                for i in range(1, len(ls)):
                    backindex[ls[i]] = (li, i - 1)
            else:
                results.append([float(x) for x in ls[1:]])
        for i in range(len(labels)):
            for j in range(len(labels[i])):
                name = labels[i][j]
                value = results[i][j]
                msg.write("%s = %s\n" % (name, value))
        (ei, ej) = backindex["Etot"]
        etot = results[ei][ej] * kcal_to_hartree

    # parse output - second, frc file
    with open(ambfrcfile, "r") as lfh:
        _header = lfh.next()
        frcs = []
        result_forces = []
        for l in lfh:
            l = l.rstrip()
            for i in range(0, len(l), 8):
                frcs.append(kcal_to_hartree / aa_to_atomiclength * float(l[i:i+8].strip()))
        for i in range(natom):
            imm = mm_of_gaussian[i]
            resblk = frcs[imm*3:(imm+1)*3]
            result_forces.append(resblk)

    print >> msg, result_forces

    # finally - output!
    with open(outputfile, "w") as fh:
        def o20_12(f):
            # TODO: if necessary replace E with D
            # gfortran may not need it
            return "%20.12f" % f
        def fformat(fs):
            return "".join([o20_12(f) for f in fs])
        def writefs(fs):
            fh.write("%s\n" % fformat(fs))
        writefs([etot, 0., 0., 0.])
        if derivative >= 1:
            for i in range(natom):
                # gradient wanted
                writefs([-x for x in result_forces[i]])
            # polarlizability
            for i in range(2):
                writefs([0., 0., 0.])
            # dipole derivatives
            for i in range(3 * natom):
                writefs([0., 0., 0.])
        if derivative == 2:
            raise RuntimeError("Second order derivative unsupported")
    
    print >> msg, "Finished external sander run"

sys.exit(0)

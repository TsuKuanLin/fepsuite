#!/usr/bin/env python
import sys
import subprocess
import os
import os.path
import re

if len(sys.argv) == 5:
    [ _exe,
      parameter,
      _layer,
      inputfile,
      outputfile ] = sys.argv
    msgfile = "debug.msg"
else:
    [ _exe,
      parameter, 
      _layer,
      inputfile,
      outputfile,
      msgfile,
      _fchkfile,
      _matelfile ] = sys.argv

sander = os.path.join(os.environ["AMBERHOME"], "bin/sander")
sanderin = "sander_pb.in"
sanderlog = "sander_pb.log"
ambtop = None
ambcrdfile = "coord.crd"
ambenefile = "energy.txt"
ambfrcfile = "force.txt"
ambdumpfrcfile = "forcedump.dat"

# You have: kcal_th / mol / avogadro
# You want: hartree
# 	* 0.0015946679
kcal_to_hartree = 0.0015936014
#
aa_to_atomiclength = 1.8897261
atomiclength_to_aa = 1. / aa_to_atomiclength

with open(msgfile, "a") as msg:
    natom = None
    mm_of_gaussian = {}
    gaussian_of_mm = {}
    with open(parameter, "r") as fh:
        ambtop = fh.next().strip()
        natom = int(fh.next().strip())
        mmatoms = []
        gaussianatoms = []
        mm_ix = {}
        gaussian_ix = {}
        for _i in range(natom):
            l = fh.next()
            [mm] = l.split()
            mm_ix[mm] = len(mmatoms)
            mmatoms.append(mm)
        for _i in range(natom):
            l = fh.next()
            [gaussian] = l.split()
            gaussian_ix[gaussian] = len(gaussianatoms)
            gaussianatoms.append(gaussian)

        for i in range(natom):
            g = gaussian_ix[mmatoms[i]]
            mm_of_gaussian[g] = i
            gaussian_of_mm[i] = g

    gaussiancrd = [None for i in range(natom)]
    with open(inputfile, "r") as ifh:
        (natomsp, derivative, _charge, _spin) = ifh.next().split()
        natomsp = int(natomsp)
        assert natom == natomsp
        derivative = int(derivative)
        for i in range(natom):
            l = ifh.next()
            [_anum, x, y, z, _mmcrg] = l.split()[0:5]
            gaussiancrd[i] = [float(e) for e in [x, y, z]]

    mmcrd = [None for i in range(natom)]
    for i in range(natom):
        mmcrd[mm_of_gaussian[i]] = [x * atomiclength_to_aa for x in gaussiancrd[i]]
    
    # Amber and Gaussian shares same coordinate unit (angstrom)
    with open(ambcrdfile, "w") as crdfh:
        crdfh.write("Generated by external\n%6d\n" % natom)
        for i in range(0, natom, 2):
            e = min(i + 2, natom)
            vals = mmcrd[i:e]
            outbuf = ""
            for v in vals:
                for e in v:
                    outbuf += "%12.7f" % e
            crdfh.write(outbuf + "\n")

    # run
    if os.path.exists(ambdumpfrcfile):
        # Amber does not overwrite ...
        os.unlink(ambdumpfrcfile)
    args = [ sander, "-O",
             "-i", sanderin,
             "-o", sanderlog,
             "-p", ambtop,
             "-c", ambcrdfile,
             "-e", ambenefile,
             "-frc", ambfrcfile ]

    print >> msg, "Calling with", args
    proc = subprocess.Popen(args)

    (stdout, stderr) = proc.communicate()
    msg.write("Stdout:\n%s\nStderr:\n%s\n" % (stdout, stderr))

    # parse output - first, ene file
    if False:
        with open(ambenefile, "r") as lfh:
            labels = []
            backindex = {}
            results = []
            for l in lfh:
                ls = l.split()
                li = int(ls[0][1:])
                if len(labels) <= li:
                    labels.append(ls[1:])
                    for i in range(1, len(ls)):
                        backindex[ls[i]] = (li, i - 1)
                else:
                    results.append([float(x) for x in ls[1:]])
            for i in range(len(labels)):
                for j in range(len(labels[i])):
                    name = labels[i][j]
                    value = results[i][j]
                    msg.write("%s = %s\n" % (name, value))
            (ei, ej) = backindex["Etot"]
            etot = results[ei][ej] * kcal_to_hartree

    # parse output - second, frc file
    with open(ambdumpfrcfile, "r") as lfh:
        header = lfh.next().strip()
        assert natom == int(header)
        # skip coordinates part
        for i in range(natom):
            lfh.next()
        l = lfh.next()
        ls = l.split()
        assert ls == ["0", "START", "of", "Energies"]
        energies = []
        for l in lfh:
            ls = l.split()
            if ls == ["1", "START", "of", "VIRIALS"]:
                break
            energies.append([float(x) for x in ls])
        etot = energies[0][0] * kcal_to_hartree
        msg.write("Energies:\n")
        for e in energies:
            msg.write("  %s\n" % repr(e))
        # skip until "2 Total Force"
        for l in lfh:
            ls = l.split()
            if ls == ["2", "Total", "Force"]:
                break
        result_forces = []
        for i in range(natom):
            l = lfh.next()
            ls = l.split()
            result_forces.append([kcal_to_hartree / aa_to_atomiclength * float(x) for x in ls])

    print >> msg, result_forces

    # finally - output!
    with open(outputfile, "w") as fh:
        def o20_12(f):
            # TODO: if necessary replace E with D
            # gfortran may not need it
            return "%20.12f" % f
        def fformat(fs):
            return "".join([o20_12(f) for f in fs])
        def writefs(fs):
            fh.write("%s\n" % fformat(fs))
        writefs([etot, 0., 0., 0.])
        if derivative >= 1:
            for i in range(natom):
                # gradient wanted
                writefs([-x for x in result_forces[i]])
            # polarlizability
            for i in range(2):
                writefs([0., 0., 0.])
            # dipole derivatives
            for i in range(3 * natom):
                writefs([0., 0., 0.])
        if derivative == 2:
            raise RuntimeError("Second order derivative unsupported")
    
    print >> msg, "Finished external sander run"

sys.exit(0)
